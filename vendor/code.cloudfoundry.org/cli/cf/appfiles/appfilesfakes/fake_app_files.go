// This file was generated by counterfeiter
package appfilesfakes

import (
	"sync"

	"code.cloudfoundry.org/cli/cf/appfiles"
	"code.cloudfoundry.org/cli/cf/models"
)

type FakeAppFiles struct {
	AppFilesInDirStub        func(dir string) (appFiles []models.AppFileFields, err error)
	appFilesInDirMutex       sync.RWMutex
	appFilesInDirArgsForCall []struct {
		dir string
	}
	appFilesInDirReturns struct {
		result1 []models.AppFileFields
		result2 error
	}
	CopyFilesStub        func(appFiles []models.AppFileFields, fromDir, toDir string) (err error)
	copyFilesMutex       sync.RWMutex
	copyFilesArgsForCall []struct {
		appFiles []models.AppFileFields
		fromDir  string
		toDir    string
	}
	copyFilesReturns struct {
		result1 error
	}
	CountFilesStub        func(directory string) int64
	countFilesMutex       sync.RWMutex
	countFilesArgsForCall []struct {
		directory string
	}
	countFilesReturns struct {
		result1 int64
	}
	WalkAppFilesStub        func(dir string, onEachFile func(string, string) error) (err error)
	walkAppFilesMutex       sync.RWMutex
	walkAppFilesArgsForCall []struct {
		dir        string
		onEachFile func(string, string) error
	}
	walkAppFilesReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAppFiles) AppFilesInDir(dir string) (appFiles []models.AppFileFields, err error) {
	fake.appFilesInDirMutex.Lock()
	fake.appFilesInDirArgsForCall = append(fake.appFilesInDirArgsForCall, struct {
		dir string
	}{dir})
	fake.recordInvocation("AppFilesInDir", []interface{}{dir})
	fake.appFilesInDirMutex.Unlock()
	if fake.AppFilesInDirStub != nil {
		return fake.AppFilesInDirStub(dir)
	} else {
		return fake.appFilesInDirReturns.result1, fake.appFilesInDirReturns.result2
	}
}

func (fake *FakeAppFiles) AppFilesInDirCallCount() int {
	fake.appFilesInDirMutex.RLock()
	defer fake.appFilesInDirMutex.RUnlock()
	return len(fake.appFilesInDirArgsForCall)
}

func (fake *FakeAppFiles) AppFilesInDirArgsForCall(i int) string {
	fake.appFilesInDirMutex.RLock()
	defer fake.appFilesInDirMutex.RUnlock()
	return fake.appFilesInDirArgsForCall[i].dir
}

func (fake *FakeAppFiles) AppFilesInDirReturns(result1 []models.AppFileFields, result2 error) {
	fake.AppFilesInDirStub = nil
	fake.appFilesInDirReturns = struct {
		result1 []models.AppFileFields
		result2 error
	}{result1, result2}
}

func (fake *FakeAppFiles) CopyFiles(appFiles []models.AppFileFields, fromDir string, toDir string) (err error) {
	var appFilesCopy []models.AppFileFields
	if appFiles != nil {
		appFilesCopy = make([]models.AppFileFields, len(appFiles))
		copy(appFilesCopy, appFiles)
	}
	fake.copyFilesMutex.Lock()
	fake.copyFilesArgsForCall = append(fake.copyFilesArgsForCall, struct {
		appFiles []models.AppFileFields
		fromDir  string
		toDir    string
	}{appFilesCopy, fromDir, toDir})
	fake.recordInvocation("CopyFiles", []interface{}{appFilesCopy, fromDir, toDir})
	fake.copyFilesMutex.Unlock()
	if fake.CopyFilesStub != nil {
		return fake.CopyFilesStub(appFiles, fromDir, toDir)
	} else {
		return fake.copyFilesReturns.result1
	}
}

func (fake *FakeAppFiles) CopyFilesCallCount() int {
	fake.copyFilesMutex.RLock()
	defer fake.copyFilesMutex.RUnlock()
	return len(fake.copyFilesArgsForCall)
}

func (fake *FakeAppFiles) CopyFilesArgsForCall(i int) ([]models.AppFileFields, string, string) {
	fake.copyFilesMutex.RLock()
	defer fake.copyFilesMutex.RUnlock()
	return fake.copyFilesArgsForCall[i].appFiles, fake.copyFilesArgsForCall[i].fromDir, fake.copyFilesArgsForCall[i].toDir
}

func (fake *FakeAppFiles) CopyFilesReturns(result1 error) {
	fake.CopyFilesStub = nil
	fake.copyFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppFiles) CountFiles(directory string) int64 {
	fake.countFilesMutex.Lock()
	fake.countFilesArgsForCall = append(fake.countFilesArgsForCall, struct {
		directory string
	}{directory})
	fake.recordInvocation("CountFiles", []interface{}{directory})
	fake.countFilesMutex.Unlock()
	if fake.CountFilesStub != nil {
		return fake.CountFilesStub(directory)
	} else {
		return fake.countFilesReturns.result1
	}
}

func (fake *FakeAppFiles) CountFilesCallCount() int {
	fake.countFilesMutex.RLock()
	defer fake.countFilesMutex.RUnlock()
	return len(fake.countFilesArgsForCall)
}

func (fake *FakeAppFiles) CountFilesArgsForCall(i int) string {
	fake.countFilesMutex.RLock()
	defer fake.countFilesMutex.RUnlock()
	return fake.countFilesArgsForCall[i].directory
}

func (fake *FakeAppFiles) CountFilesReturns(result1 int64) {
	fake.CountFilesStub = nil
	fake.countFilesReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeAppFiles) WalkAppFiles(dir string, onEachFile func(string, string) error) (err error) {
	fake.walkAppFilesMutex.Lock()
	fake.walkAppFilesArgsForCall = append(fake.walkAppFilesArgsForCall, struct {
		dir        string
		onEachFile func(string, string) error
	}{dir, onEachFile})
	fake.recordInvocation("WalkAppFiles", []interface{}{dir, onEachFile})
	fake.walkAppFilesMutex.Unlock()
	if fake.WalkAppFilesStub != nil {
		return fake.WalkAppFilesStub(dir, onEachFile)
	} else {
		return fake.walkAppFilesReturns.result1
	}
}

func (fake *FakeAppFiles) WalkAppFilesCallCount() int {
	fake.walkAppFilesMutex.RLock()
	defer fake.walkAppFilesMutex.RUnlock()
	return len(fake.walkAppFilesArgsForCall)
}

func (fake *FakeAppFiles) WalkAppFilesArgsForCall(i int) (string, func(string, string) error) {
	fake.walkAppFilesMutex.RLock()
	defer fake.walkAppFilesMutex.RUnlock()
	return fake.walkAppFilesArgsForCall[i].dir, fake.walkAppFilesArgsForCall[i].onEachFile
}

func (fake *FakeAppFiles) WalkAppFilesReturns(result1 error) {
	fake.WalkAppFilesStub = nil
	fake.walkAppFilesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAppFiles) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.appFilesInDirMutex.RLock()
	defer fake.appFilesInDirMutex.RUnlock()
	fake.copyFilesMutex.RLock()
	defer fake.copyFilesMutex.RUnlock()
	fake.countFilesMutex.RLock()
	defer fake.countFilesMutex.RUnlock()
	fake.walkAppFilesMutex.RLock()
	defer fake.walkAppFilesMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeAppFiles) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ appfiles.AppFiles = new(FakeAppFiles)
