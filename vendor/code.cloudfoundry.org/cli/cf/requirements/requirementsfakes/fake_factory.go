// Code generated by counterfeiter. DO NOT EDIT.
package requirementsfakes

import (
	"sync"

	"code.cloudfoundry.org/cli/cf/requirements"
	"github.com/blang/semver"
)

type FakeFactory struct {
	NewApplicationRequirementStub        func(name string) requirements.ApplicationRequirement
	newApplicationRequirementMutex       sync.RWMutex
	newApplicationRequirementArgsForCall []struct {
		name string
	}
	newApplicationRequirementReturns struct {
		result1 requirements.ApplicationRequirement
	}
	newApplicationRequirementReturnsOnCall map[int]struct {
		result1 requirements.ApplicationRequirement
	}
	NewDEAApplicationRequirementStub        func(name string) requirements.DEAApplicationRequirement
	newDEAApplicationRequirementMutex       sync.RWMutex
	newDEAApplicationRequirementArgsForCall []struct {
		name string
	}
	newDEAApplicationRequirementReturns struct {
		result1 requirements.DEAApplicationRequirement
	}
	newDEAApplicationRequirementReturnsOnCall map[int]struct {
		result1 requirements.DEAApplicationRequirement
	}
	NewServiceInstanceRequirementStub        func(name string) requirements.ServiceInstanceRequirement
	newServiceInstanceRequirementMutex       sync.RWMutex
	newServiceInstanceRequirementArgsForCall []struct {
		name string
	}
	newServiceInstanceRequirementReturns struct {
		result1 requirements.ServiceInstanceRequirement
	}
	newServiceInstanceRequirementReturnsOnCall map[int]struct {
		result1 requirements.ServiceInstanceRequirement
	}
	NewLoginRequirementStub        func() requirements.Requirement
	newLoginRequirementMutex       sync.RWMutex
	newLoginRequirementArgsForCall []struct{}
	newLoginRequirementReturns     struct {
		result1 requirements.Requirement
	}
	newLoginRequirementReturnsOnCall map[int]struct {
		result1 requirements.Requirement
	}
	NewSpaceRequirementStub        func(name string) requirements.SpaceRequirement
	newSpaceRequirementMutex       sync.RWMutex
	newSpaceRequirementArgsForCall []struct {
		name string
	}
	newSpaceRequirementReturns struct {
		result1 requirements.SpaceRequirement
	}
	newSpaceRequirementReturnsOnCall map[int]struct {
		result1 requirements.SpaceRequirement
	}
	NewTargetedSpaceRequirementStub        func() requirements.Requirement
	newTargetedSpaceRequirementMutex       sync.RWMutex
	newTargetedSpaceRequirementArgsForCall []struct{}
	newTargetedSpaceRequirementReturns     struct {
		result1 requirements.Requirement
	}
	newTargetedSpaceRequirementReturnsOnCall map[int]struct {
		result1 requirements.Requirement
	}
	NewTargetedOrgRequirementStub        func() requirements.TargetedOrgRequirement
	newTargetedOrgRequirementMutex       sync.RWMutex
	newTargetedOrgRequirementArgsForCall []struct{}
	newTargetedOrgRequirementReturns     struct {
		result1 requirements.TargetedOrgRequirement
	}
	newTargetedOrgRequirementReturnsOnCall map[int]struct {
		result1 requirements.TargetedOrgRequirement
	}
	NewOrganizationRequirementStub        func(name string) requirements.OrganizationRequirement
	newOrganizationRequirementMutex       sync.RWMutex
	newOrganizationRequirementArgsForCall []struct {
		name string
	}
	newOrganizationRequirementReturns struct {
		result1 requirements.OrganizationRequirement
	}
	newOrganizationRequirementReturnsOnCall map[int]struct {
		result1 requirements.OrganizationRequirement
	}
	NewDomainRequirementStub        func(name string) requirements.DomainRequirement
	newDomainRequirementMutex       sync.RWMutex
	newDomainRequirementArgsForCall []struct {
		name string
	}
	newDomainRequirementReturns struct {
		result1 requirements.DomainRequirement
	}
	newDomainRequirementReturnsOnCall map[int]struct {
		result1 requirements.DomainRequirement
	}
	NewUserRequirementStub        func(username string, wantGUID bool) requirements.UserRequirement
	newUserRequirementMutex       sync.RWMutex
	newUserRequirementArgsForCall []struct {
		username string
		wantGUID bool
	}
	newUserRequirementReturns struct {
		result1 requirements.UserRequirement
	}
	newUserRequirementReturnsOnCall map[int]struct {
		result1 requirements.UserRequirement
	}
	NewBuildpackRequirementStub        func(buildpack, stack string) requirements.BuildpackRequirement
	newBuildpackRequirementMutex       sync.RWMutex
	newBuildpackRequirementArgsForCall []struct {
		buildpack string
		stack     string
	}
	newBuildpackRequirementReturns struct {
		result1 requirements.BuildpackRequirement
	}
	newBuildpackRequirementReturnsOnCall map[int]struct {
		result1 requirements.BuildpackRequirement
	}
	NewAPIEndpointRequirementStub        func() requirements.Requirement
	newAPIEndpointRequirementMutex       sync.RWMutex
	newAPIEndpointRequirementArgsForCall []struct{}
	newAPIEndpointRequirementReturns     struct {
		result1 requirements.Requirement
	}
	newAPIEndpointRequirementReturnsOnCall map[int]struct {
		result1 requirements.Requirement
	}
	NewMinAPIVersionRequirementStub        func(commandName string, requiredVersion semver.Version) requirements.Requirement
	newMinAPIVersionRequirementMutex       sync.RWMutex
	newMinAPIVersionRequirementArgsForCall []struct {
		commandName     string
		requiredVersion semver.Version
	}
	newMinAPIVersionRequirementReturns struct {
		result1 requirements.Requirement
	}
	newMinAPIVersionRequirementReturnsOnCall map[int]struct {
		result1 requirements.Requirement
	}
	NewMaxAPIVersionRequirementStub        func(commandName string, maximumVersion semver.Version) requirements.Requirement
	newMaxAPIVersionRequirementMutex       sync.RWMutex
	newMaxAPIVersionRequirementArgsForCall []struct {
		commandName    string
		maximumVersion semver.Version
	}
	newMaxAPIVersionRequirementReturns struct {
		result1 requirements.Requirement
	}
	newMaxAPIVersionRequirementReturnsOnCall map[int]struct {
		result1 requirements.Requirement
	}
	NewUnsupportedLegacyFlagRequirementStub        func(flags ...string) requirements.Requirement
	newUnsupportedLegacyFlagRequirementMutex       sync.RWMutex
	newUnsupportedLegacyFlagRequirementArgsForCall []struct {
		flags []string
	}
	newUnsupportedLegacyFlagRequirementReturns struct {
		result1 requirements.Requirement
	}
	newUnsupportedLegacyFlagRequirementReturnsOnCall map[int]struct {
		result1 requirements.Requirement
	}
	NewUsageRequirementStub        func(requirements.Usable, string, func() bool) requirements.Requirement
	newUsageRequirementMutex       sync.RWMutex
	newUsageRequirementArgsForCall []struct {
		arg1 requirements.Usable
		arg2 string
		arg3 func() bool
	}
	newUsageRequirementReturns struct {
		result1 requirements.Requirement
	}
	newUsageRequirementReturnsOnCall map[int]struct {
		result1 requirements.Requirement
	}
	NewNumberArgumentsStub        func([]string, ...string) requirements.Requirement
	newNumberArgumentsMutex       sync.RWMutex
	newNumberArgumentsArgsForCall []struct {
		arg1 []string
		arg2 []string
	}
	newNumberArgumentsReturns struct {
		result1 requirements.Requirement
	}
	newNumberArgumentsReturnsOnCall map[int]struct {
		result1 requirements.Requirement
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFactory) NewApplicationRequirement(name string) requirements.ApplicationRequirement {
	fake.newApplicationRequirementMutex.Lock()
	ret, specificReturn := fake.newApplicationRequirementReturnsOnCall[len(fake.newApplicationRequirementArgsForCall)]
	fake.newApplicationRequirementArgsForCall = append(fake.newApplicationRequirementArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("NewApplicationRequirement", []interface{}{name})
	fake.newApplicationRequirementMutex.Unlock()
	if fake.NewApplicationRequirementStub != nil {
		return fake.NewApplicationRequirementStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newApplicationRequirementReturns.result1
}

func (fake *FakeFactory) NewApplicationRequirementCallCount() int {
	fake.newApplicationRequirementMutex.RLock()
	defer fake.newApplicationRequirementMutex.RUnlock()
	return len(fake.newApplicationRequirementArgsForCall)
}

func (fake *FakeFactory) NewApplicationRequirementArgsForCall(i int) string {
	fake.newApplicationRequirementMutex.RLock()
	defer fake.newApplicationRequirementMutex.RUnlock()
	return fake.newApplicationRequirementArgsForCall[i].name
}

func (fake *FakeFactory) NewApplicationRequirementReturns(result1 requirements.ApplicationRequirement) {
	fake.NewApplicationRequirementStub = nil
	fake.newApplicationRequirementReturns = struct {
		result1 requirements.ApplicationRequirement
	}{result1}
}

func (fake *FakeFactory) NewApplicationRequirementReturnsOnCall(i int, result1 requirements.ApplicationRequirement) {
	fake.NewApplicationRequirementStub = nil
	if fake.newApplicationRequirementReturnsOnCall == nil {
		fake.newApplicationRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.ApplicationRequirement
		})
	}
	fake.newApplicationRequirementReturnsOnCall[i] = struct {
		result1 requirements.ApplicationRequirement
	}{result1}
}

func (fake *FakeFactory) NewDEAApplicationRequirement(name string) requirements.DEAApplicationRequirement {
	fake.newDEAApplicationRequirementMutex.Lock()
	ret, specificReturn := fake.newDEAApplicationRequirementReturnsOnCall[len(fake.newDEAApplicationRequirementArgsForCall)]
	fake.newDEAApplicationRequirementArgsForCall = append(fake.newDEAApplicationRequirementArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("NewDEAApplicationRequirement", []interface{}{name})
	fake.newDEAApplicationRequirementMutex.Unlock()
	if fake.NewDEAApplicationRequirementStub != nil {
		return fake.NewDEAApplicationRequirementStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newDEAApplicationRequirementReturns.result1
}

func (fake *FakeFactory) NewDEAApplicationRequirementCallCount() int {
	fake.newDEAApplicationRequirementMutex.RLock()
	defer fake.newDEAApplicationRequirementMutex.RUnlock()
	return len(fake.newDEAApplicationRequirementArgsForCall)
}

func (fake *FakeFactory) NewDEAApplicationRequirementArgsForCall(i int) string {
	fake.newDEAApplicationRequirementMutex.RLock()
	defer fake.newDEAApplicationRequirementMutex.RUnlock()
	return fake.newDEAApplicationRequirementArgsForCall[i].name
}

func (fake *FakeFactory) NewDEAApplicationRequirementReturns(result1 requirements.DEAApplicationRequirement) {
	fake.NewDEAApplicationRequirementStub = nil
	fake.newDEAApplicationRequirementReturns = struct {
		result1 requirements.DEAApplicationRequirement
	}{result1}
}

func (fake *FakeFactory) NewDEAApplicationRequirementReturnsOnCall(i int, result1 requirements.DEAApplicationRequirement) {
	fake.NewDEAApplicationRequirementStub = nil
	if fake.newDEAApplicationRequirementReturnsOnCall == nil {
		fake.newDEAApplicationRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.DEAApplicationRequirement
		})
	}
	fake.newDEAApplicationRequirementReturnsOnCall[i] = struct {
		result1 requirements.DEAApplicationRequirement
	}{result1}
}

func (fake *FakeFactory) NewServiceInstanceRequirement(name string) requirements.ServiceInstanceRequirement {
	fake.newServiceInstanceRequirementMutex.Lock()
	ret, specificReturn := fake.newServiceInstanceRequirementReturnsOnCall[len(fake.newServiceInstanceRequirementArgsForCall)]
	fake.newServiceInstanceRequirementArgsForCall = append(fake.newServiceInstanceRequirementArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("NewServiceInstanceRequirement", []interface{}{name})
	fake.newServiceInstanceRequirementMutex.Unlock()
	if fake.NewServiceInstanceRequirementStub != nil {
		return fake.NewServiceInstanceRequirementStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newServiceInstanceRequirementReturns.result1
}

func (fake *FakeFactory) NewServiceInstanceRequirementCallCount() int {
	fake.newServiceInstanceRequirementMutex.RLock()
	defer fake.newServiceInstanceRequirementMutex.RUnlock()
	return len(fake.newServiceInstanceRequirementArgsForCall)
}

func (fake *FakeFactory) NewServiceInstanceRequirementArgsForCall(i int) string {
	fake.newServiceInstanceRequirementMutex.RLock()
	defer fake.newServiceInstanceRequirementMutex.RUnlock()
	return fake.newServiceInstanceRequirementArgsForCall[i].name
}

func (fake *FakeFactory) NewServiceInstanceRequirementReturns(result1 requirements.ServiceInstanceRequirement) {
	fake.NewServiceInstanceRequirementStub = nil
	fake.newServiceInstanceRequirementReturns = struct {
		result1 requirements.ServiceInstanceRequirement
	}{result1}
}

func (fake *FakeFactory) NewServiceInstanceRequirementReturnsOnCall(i int, result1 requirements.ServiceInstanceRequirement) {
	fake.NewServiceInstanceRequirementStub = nil
	if fake.newServiceInstanceRequirementReturnsOnCall == nil {
		fake.newServiceInstanceRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.ServiceInstanceRequirement
		})
	}
	fake.newServiceInstanceRequirementReturnsOnCall[i] = struct {
		result1 requirements.ServiceInstanceRequirement
	}{result1}
}

func (fake *FakeFactory) NewLoginRequirement() requirements.Requirement {
	fake.newLoginRequirementMutex.Lock()
	ret, specificReturn := fake.newLoginRequirementReturnsOnCall[len(fake.newLoginRequirementArgsForCall)]
	fake.newLoginRequirementArgsForCall = append(fake.newLoginRequirementArgsForCall, struct{}{})
	fake.recordInvocation("NewLoginRequirement", []interface{}{})
	fake.newLoginRequirementMutex.Unlock()
	if fake.NewLoginRequirementStub != nil {
		return fake.NewLoginRequirementStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newLoginRequirementReturns.result1
}

func (fake *FakeFactory) NewLoginRequirementCallCount() int {
	fake.newLoginRequirementMutex.RLock()
	defer fake.newLoginRequirementMutex.RUnlock()
	return len(fake.newLoginRequirementArgsForCall)
}

func (fake *FakeFactory) NewLoginRequirementReturns(result1 requirements.Requirement) {
	fake.NewLoginRequirementStub = nil
	fake.newLoginRequirementReturns = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewLoginRequirementReturnsOnCall(i int, result1 requirements.Requirement) {
	fake.NewLoginRequirementStub = nil
	if fake.newLoginRequirementReturnsOnCall == nil {
		fake.newLoginRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.Requirement
		})
	}
	fake.newLoginRequirementReturnsOnCall[i] = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewSpaceRequirement(name string) requirements.SpaceRequirement {
	fake.newSpaceRequirementMutex.Lock()
	ret, specificReturn := fake.newSpaceRequirementReturnsOnCall[len(fake.newSpaceRequirementArgsForCall)]
	fake.newSpaceRequirementArgsForCall = append(fake.newSpaceRequirementArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("NewSpaceRequirement", []interface{}{name})
	fake.newSpaceRequirementMutex.Unlock()
	if fake.NewSpaceRequirementStub != nil {
		return fake.NewSpaceRequirementStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newSpaceRequirementReturns.result1
}

func (fake *FakeFactory) NewSpaceRequirementCallCount() int {
	fake.newSpaceRequirementMutex.RLock()
	defer fake.newSpaceRequirementMutex.RUnlock()
	return len(fake.newSpaceRequirementArgsForCall)
}

func (fake *FakeFactory) NewSpaceRequirementArgsForCall(i int) string {
	fake.newSpaceRequirementMutex.RLock()
	defer fake.newSpaceRequirementMutex.RUnlock()
	return fake.newSpaceRequirementArgsForCall[i].name
}

func (fake *FakeFactory) NewSpaceRequirementReturns(result1 requirements.SpaceRequirement) {
	fake.NewSpaceRequirementStub = nil
	fake.newSpaceRequirementReturns = struct {
		result1 requirements.SpaceRequirement
	}{result1}
}

func (fake *FakeFactory) NewSpaceRequirementReturnsOnCall(i int, result1 requirements.SpaceRequirement) {
	fake.NewSpaceRequirementStub = nil
	if fake.newSpaceRequirementReturnsOnCall == nil {
		fake.newSpaceRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.SpaceRequirement
		})
	}
	fake.newSpaceRequirementReturnsOnCall[i] = struct {
		result1 requirements.SpaceRequirement
	}{result1}
}

func (fake *FakeFactory) NewTargetedSpaceRequirement() requirements.Requirement {
	fake.newTargetedSpaceRequirementMutex.Lock()
	ret, specificReturn := fake.newTargetedSpaceRequirementReturnsOnCall[len(fake.newTargetedSpaceRequirementArgsForCall)]
	fake.newTargetedSpaceRequirementArgsForCall = append(fake.newTargetedSpaceRequirementArgsForCall, struct{}{})
	fake.recordInvocation("NewTargetedSpaceRequirement", []interface{}{})
	fake.newTargetedSpaceRequirementMutex.Unlock()
	if fake.NewTargetedSpaceRequirementStub != nil {
		return fake.NewTargetedSpaceRequirementStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newTargetedSpaceRequirementReturns.result1
}

func (fake *FakeFactory) NewTargetedSpaceRequirementCallCount() int {
	fake.newTargetedSpaceRequirementMutex.RLock()
	defer fake.newTargetedSpaceRequirementMutex.RUnlock()
	return len(fake.newTargetedSpaceRequirementArgsForCall)
}

func (fake *FakeFactory) NewTargetedSpaceRequirementReturns(result1 requirements.Requirement) {
	fake.NewTargetedSpaceRequirementStub = nil
	fake.newTargetedSpaceRequirementReturns = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewTargetedSpaceRequirementReturnsOnCall(i int, result1 requirements.Requirement) {
	fake.NewTargetedSpaceRequirementStub = nil
	if fake.newTargetedSpaceRequirementReturnsOnCall == nil {
		fake.newTargetedSpaceRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.Requirement
		})
	}
	fake.newTargetedSpaceRequirementReturnsOnCall[i] = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewTargetedOrgRequirement() requirements.TargetedOrgRequirement {
	fake.newTargetedOrgRequirementMutex.Lock()
	ret, specificReturn := fake.newTargetedOrgRequirementReturnsOnCall[len(fake.newTargetedOrgRequirementArgsForCall)]
	fake.newTargetedOrgRequirementArgsForCall = append(fake.newTargetedOrgRequirementArgsForCall, struct{}{})
	fake.recordInvocation("NewTargetedOrgRequirement", []interface{}{})
	fake.newTargetedOrgRequirementMutex.Unlock()
	if fake.NewTargetedOrgRequirementStub != nil {
		return fake.NewTargetedOrgRequirementStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newTargetedOrgRequirementReturns.result1
}

func (fake *FakeFactory) NewTargetedOrgRequirementCallCount() int {
	fake.newTargetedOrgRequirementMutex.RLock()
	defer fake.newTargetedOrgRequirementMutex.RUnlock()
	return len(fake.newTargetedOrgRequirementArgsForCall)
}

func (fake *FakeFactory) NewTargetedOrgRequirementReturns(result1 requirements.TargetedOrgRequirement) {
	fake.NewTargetedOrgRequirementStub = nil
	fake.newTargetedOrgRequirementReturns = struct {
		result1 requirements.TargetedOrgRequirement
	}{result1}
}

func (fake *FakeFactory) NewTargetedOrgRequirementReturnsOnCall(i int, result1 requirements.TargetedOrgRequirement) {
	fake.NewTargetedOrgRequirementStub = nil
	if fake.newTargetedOrgRequirementReturnsOnCall == nil {
		fake.newTargetedOrgRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.TargetedOrgRequirement
		})
	}
	fake.newTargetedOrgRequirementReturnsOnCall[i] = struct {
		result1 requirements.TargetedOrgRequirement
	}{result1}
}

func (fake *FakeFactory) NewOrganizationRequirement(name string) requirements.OrganizationRequirement {
	fake.newOrganizationRequirementMutex.Lock()
	ret, specificReturn := fake.newOrganizationRequirementReturnsOnCall[len(fake.newOrganizationRequirementArgsForCall)]
	fake.newOrganizationRequirementArgsForCall = append(fake.newOrganizationRequirementArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("NewOrganizationRequirement", []interface{}{name})
	fake.newOrganizationRequirementMutex.Unlock()
	if fake.NewOrganizationRequirementStub != nil {
		return fake.NewOrganizationRequirementStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newOrganizationRequirementReturns.result1
}

func (fake *FakeFactory) NewOrganizationRequirementCallCount() int {
	fake.newOrganizationRequirementMutex.RLock()
	defer fake.newOrganizationRequirementMutex.RUnlock()
	return len(fake.newOrganizationRequirementArgsForCall)
}

func (fake *FakeFactory) NewOrganizationRequirementArgsForCall(i int) string {
	fake.newOrganizationRequirementMutex.RLock()
	defer fake.newOrganizationRequirementMutex.RUnlock()
	return fake.newOrganizationRequirementArgsForCall[i].name
}

func (fake *FakeFactory) NewOrganizationRequirementReturns(result1 requirements.OrganizationRequirement) {
	fake.NewOrganizationRequirementStub = nil
	fake.newOrganizationRequirementReturns = struct {
		result1 requirements.OrganizationRequirement
	}{result1}
}

func (fake *FakeFactory) NewOrganizationRequirementReturnsOnCall(i int, result1 requirements.OrganizationRequirement) {
	fake.NewOrganizationRequirementStub = nil
	if fake.newOrganizationRequirementReturnsOnCall == nil {
		fake.newOrganizationRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.OrganizationRequirement
		})
	}
	fake.newOrganizationRequirementReturnsOnCall[i] = struct {
		result1 requirements.OrganizationRequirement
	}{result1}
}

func (fake *FakeFactory) NewDomainRequirement(name string) requirements.DomainRequirement {
	fake.newDomainRequirementMutex.Lock()
	ret, specificReturn := fake.newDomainRequirementReturnsOnCall[len(fake.newDomainRequirementArgsForCall)]
	fake.newDomainRequirementArgsForCall = append(fake.newDomainRequirementArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("NewDomainRequirement", []interface{}{name})
	fake.newDomainRequirementMutex.Unlock()
	if fake.NewDomainRequirementStub != nil {
		return fake.NewDomainRequirementStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newDomainRequirementReturns.result1
}

func (fake *FakeFactory) NewDomainRequirementCallCount() int {
	fake.newDomainRequirementMutex.RLock()
	defer fake.newDomainRequirementMutex.RUnlock()
	return len(fake.newDomainRequirementArgsForCall)
}

func (fake *FakeFactory) NewDomainRequirementArgsForCall(i int) string {
	fake.newDomainRequirementMutex.RLock()
	defer fake.newDomainRequirementMutex.RUnlock()
	return fake.newDomainRequirementArgsForCall[i].name
}

func (fake *FakeFactory) NewDomainRequirementReturns(result1 requirements.DomainRequirement) {
	fake.NewDomainRequirementStub = nil
	fake.newDomainRequirementReturns = struct {
		result1 requirements.DomainRequirement
	}{result1}
}

func (fake *FakeFactory) NewDomainRequirementReturnsOnCall(i int, result1 requirements.DomainRequirement) {
	fake.NewDomainRequirementStub = nil
	if fake.newDomainRequirementReturnsOnCall == nil {
		fake.newDomainRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.DomainRequirement
		})
	}
	fake.newDomainRequirementReturnsOnCall[i] = struct {
		result1 requirements.DomainRequirement
	}{result1}
}

func (fake *FakeFactory) NewUserRequirement(username string, wantGUID bool) requirements.UserRequirement {
	fake.newUserRequirementMutex.Lock()
	ret, specificReturn := fake.newUserRequirementReturnsOnCall[len(fake.newUserRequirementArgsForCall)]
	fake.newUserRequirementArgsForCall = append(fake.newUserRequirementArgsForCall, struct {
		username string
		wantGUID bool
	}{username, wantGUID})
	fake.recordInvocation("NewUserRequirement", []interface{}{username, wantGUID})
	fake.newUserRequirementMutex.Unlock()
	if fake.NewUserRequirementStub != nil {
		return fake.NewUserRequirementStub(username, wantGUID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newUserRequirementReturns.result1
}

func (fake *FakeFactory) NewUserRequirementCallCount() int {
	fake.newUserRequirementMutex.RLock()
	defer fake.newUserRequirementMutex.RUnlock()
	return len(fake.newUserRequirementArgsForCall)
}

func (fake *FakeFactory) NewUserRequirementArgsForCall(i int) (string, bool) {
	fake.newUserRequirementMutex.RLock()
	defer fake.newUserRequirementMutex.RUnlock()
	return fake.newUserRequirementArgsForCall[i].username, fake.newUserRequirementArgsForCall[i].wantGUID
}

func (fake *FakeFactory) NewUserRequirementReturns(result1 requirements.UserRequirement) {
	fake.NewUserRequirementStub = nil
	fake.newUserRequirementReturns = struct {
		result1 requirements.UserRequirement
	}{result1}
}

func (fake *FakeFactory) NewUserRequirementReturnsOnCall(i int, result1 requirements.UserRequirement) {
	fake.NewUserRequirementStub = nil
	if fake.newUserRequirementReturnsOnCall == nil {
		fake.newUserRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.UserRequirement
		})
	}
	fake.newUserRequirementReturnsOnCall[i] = struct {
		result1 requirements.UserRequirement
	}{result1}
}

func (fake *FakeFactory) NewBuildpackRequirement(buildpack string, stack string) requirements.BuildpackRequirement {
	fake.newBuildpackRequirementMutex.Lock()
	ret, specificReturn := fake.newBuildpackRequirementReturnsOnCall[len(fake.newBuildpackRequirementArgsForCall)]
	fake.newBuildpackRequirementArgsForCall = append(fake.newBuildpackRequirementArgsForCall, struct {
		buildpack string
		stack     string
	}{buildpack, stack})
	fake.recordInvocation("NewBuildpackRequirement", []interface{}{buildpack, stack})
	fake.newBuildpackRequirementMutex.Unlock()
	if fake.NewBuildpackRequirementStub != nil {
		return fake.NewBuildpackRequirementStub(buildpack, stack)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newBuildpackRequirementReturns.result1
}

func (fake *FakeFactory) NewBuildpackRequirementCallCount() int {
	fake.newBuildpackRequirementMutex.RLock()
	defer fake.newBuildpackRequirementMutex.RUnlock()
	return len(fake.newBuildpackRequirementArgsForCall)
}

func (fake *FakeFactory) NewBuildpackRequirementArgsForCall(i int) (string, string) {
	fake.newBuildpackRequirementMutex.RLock()
	defer fake.newBuildpackRequirementMutex.RUnlock()
	return fake.newBuildpackRequirementArgsForCall[i].buildpack, fake.newBuildpackRequirementArgsForCall[i].stack
}

func (fake *FakeFactory) NewBuildpackRequirementReturns(result1 requirements.BuildpackRequirement) {
	fake.NewBuildpackRequirementStub = nil
	fake.newBuildpackRequirementReturns = struct {
		result1 requirements.BuildpackRequirement
	}{result1}
}

func (fake *FakeFactory) NewBuildpackRequirementReturnsOnCall(i int, result1 requirements.BuildpackRequirement) {
	fake.NewBuildpackRequirementStub = nil
	if fake.newBuildpackRequirementReturnsOnCall == nil {
		fake.newBuildpackRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.BuildpackRequirement
		})
	}
	fake.newBuildpackRequirementReturnsOnCall[i] = struct {
		result1 requirements.BuildpackRequirement
	}{result1}
}

func (fake *FakeFactory) NewAPIEndpointRequirement() requirements.Requirement {
	fake.newAPIEndpointRequirementMutex.Lock()
	ret, specificReturn := fake.newAPIEndpointRequirementReturnsOnCall[len(fake.newAPIEndpointRequirementArgsForCall)]
	fake.newAPIEndpointRequirementArgsForCall = append(fake.newAPIEndpointRequirementArgsForCall, struct{}{})
	fake.recordInvocation("NewAPIEndpointRequirement", []interface{}{})
	fake.newAPIEndpointRequirementMutex.Unlock()
	if fake.NewAPIEndpointRequirementStub != nil {
		return fake.NewAPIEndpointRequirementStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newAPIEndpointRequirementReturns.result1
}

func (fake *FakeFactory) NewAPIEndpointRequirementCallCount() int {
	fake.newAPIEndpointRequirementMutex.RLock()
	defer fake.newAPIEndpointRequirementMutex.RUnlock()
	return len(fake.newAPIEndpointRequirementArgsForCall)
}

func (fake *FakeFactory) NewAPIEndpointRequirementReturns(result1 requirements.Requirement) {
	fake.NewAPIEndpointRequirementStub = nil
	fake.newAPIEndpointRequirementReturns = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewAPIEndpointRequirementReturnsOnCall(i int, result1 requirements.Requirement) {
	fake.NewAPIEndpointRequirementStub = nil
	if fake.newAPIEndpointRequirementReturnsOnCall == nil {
		fake.newAPIEndpointRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.Requirement
		})
	}
	fake.newAPIEndpointRequirementReturnsOnCall[i] = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewMinAPIVersionRequirement(commandName string, requiredVersion semver.Version) requirements.Requirement {
	fake.newMinAPIVersionRequirementMutex.Lock()
	ret, specificReturn := fake.newMinAPIVersionRequirementReturnsOnCall[len(fake.newMinAPIVersionRequirementArgsForCall)]
	fake.newMinAPIVersionRequirementArgsForCall = append(fake.newMinAPIVersionRequirementArgsForCall, struct {
		commandName     string
		requiredVersion semver.Version
	}{commandName, requiredVersion})
	fake.recordInvocation("NewMinAPIVersionRequirement", []interface{}{commandName, requiredVersion})
	fake.newMinAPIVersionRequirementMutex.Unlock()
	if fake.NewMinAPIVersionRequirementStub != nil {
		return fake.NewMinAPIVersionRequirementStub(commandName, requiredVersion)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newMinAPIVersionRequirementReturns.result1
}

func (fake *FakeFactory) NewMinAPIVersionRequirementCallCount() int {
	fake.newMinAPIVersionRequirementMutex.RLock()
	defer fake.newMinAPIVersionRequirementMutex.RUnlock()
	return len(fake.newMinAPIVersionRequirementArgsForCall)
}

func (fake *FakeFactory) NewMinAPIVersionRequirementArgsForCall(i int) (string, semver.Version) {
	fake.newMinAPIVersionRequirementMutex.RLock()
	defer fake.newMinAPIVersionRequirementMutex.RUnlock()
	return fake.newMinAPIVersionRequirementArgsForCall[i].commandName, fake.newMinAPIVersionRequirementArgsForCall[i].requiredVersion
}

func (fake *FakeFactory) NewMinAPIVersionRequirementReturns(result1 requirements.Requirement) {
	fake.NewMinAPIVersionRequirementStub = nil
	fake.newMinAPIVersionRequirementReturns = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewMinAPIVersionRequirementReturnsOnCall(i int, result1 requirements.Requirement) {
	fake.NewMinAPIVersionRequirementStub = nil
	if fake.newMinAPIVersionRequirementReturnsOnCall == nil {
		fake.newMinAPIVersionRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.Requirement
		})
	}
	fake.newMinAPIVersionRequirementReturnsOnCall[i] = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewMaxAPIVersionRequirement(commandName string, maximumVersion semver.Version) requirements.Requirement {
	fake.newMaxAPIVersionRequirementMutex.Lock()
	ret, specificReturn := fake.newMaxAPIVersionRequirementReturnsOnCall[len(fake.newMaxAPIVersionRequirementArgsForCall)]
	fake.newMaxAPIVersionRequirementArgsForCall = append(fake.newMaxAPIVersionRequirementArgsForCall, struct {
		commandName    string
		maximumVersion semver.Version
	}{commandName, maximumVersion})
	fake.recordInvocation("NewMaxAPIVersionRequirement", []interface{}{commandName, maximumVersion})
	fake.newMaxAPIVersionRequirementMutex.Unlock()
	if fake.NewMaxAPIVersionRequirementStub != nil {
		return fake.NewMaxAPIVersionRequirementStub(commandName, maximumVersion)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newMaxAPIVersionRequirementReturns.result1
}

func (fake *FakeFactory) NewMaxAPIVersionRequirementCallCount() int {
	fake.newMaxAPIVersionRequirementMutex.RLock()
	defer fake.newMaxAPIVersionRequirementMutex.RUnlock()
	return len(fake.newMaxAPIVersionRequirementArgsForCall)
}

func (fake *FakeFactory) NewMaxAPIVersionRequirementArgsForCall(i int) (string, semver.Version) {
	fake.newMaxAPIVersionRequirementMutex.RLock()
	defer fake.newMaxAPIVersionRequirementMutex.RUnlock()
	return fake.newMaxAPIVersionRequirementArgsForCall[i].commandName, fake.newMaxAPIVersionRequirementArgsForCall[i].maximumVersion
}

func (fake *FakeFactory) NewMaxAPIVersionRequirementReturns(result1 requirements.Requirement) {
	fake.NewMaxAPIVersionRequirementStub = nil
	fake.newMaxAPIVersionRequirementReturns = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewMaxAPIVersionRequirementReturnsOnCall(i int, result1 requirements.Requirement) {
	fake.NewMaxAPIVersionRequirementStub = nil
	if fake.newMaxAPIVersionRequirementReturnsOnCall == nil {
		fake.newMaxAPIVersionRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.Requirement
		})
	}
	fake.newMaxAPIVersionRequirementReturnsOnCall[i] = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewUnsupportedLegacyFlagRequirement(flags ...string) requirements.Requirement {
	fake.newUnsupportedLegacyFlagRequirementMutex.Lock()
	ret, specificReturn := fake.newUnsupportedLegacyFlagRequirementReturnsOnCall[len(fake.newUnsupportedLegacyFlagRequirementArgsForCall)]
	fake.newUnsupportedLegacyFlagRequirementArgsForCall = append(fake.newUnsupportedLegacyFlagRequirementArgsForCall, struct {
		flags []string
	}{flags})
	fake.recordInvocation("NewUnsupportedLegacyFlagRequirement", []interface{}{flags})
	fake.newUnsupportedLegacyFlagRequirementMutex.Unlock()
	if fake.NewUnsupportedLegacyFlagRequirementStub != nil {
		return fake.NewUnsupportedLegacyFlagRequirementStub(flags...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newUnsupportedLegacyFlagRequirementReturns.result1
}

func (fake *FakeFactory) NewUnsupportedLegacyFlagRequirementCallCount() int {
	fake.newUnsupportedLegacyFlagRequirementMutex.RLock()
	defer fake.newUnsupportedLegacyFlagRequirementMutex.RUnlock()
	return len(fake.newUnsupportedLegacyFlagRequirementArgsForCall)
}

func (fake *FakeFactory) NewUnsupportedLegacyFlagRequirementArgsForCall(i int) []string {
	fake.newUnsupportedLegacyFlagRequirementMutex.RLock()
	defer fake.newUnsupportedLegacyFlagRequirementMutex.RUnlock()
	return fake.newUnsupportedLegacyFlagRequirementArgsForCall[i].flags
}

func (fake *FakeFactory) NewUnsupportedLegacyFlagRequirementReturns(result1 requirements.Requirement) {
	fake.NewUnsupportedLegacyFlagRequirementStub = nil
	fake.newUnsupportedLegacyFlagRequirementReturns = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewUnsupportedLegacyFlagRequirementReturnsOnCall(i int, result1 requirements.Requirement) {
	fake.NewUnsupportedLegacyFlagRequirementStub = nil
	if fake.newUnsupportedLegacyFlagRequirementReturnsOnCall == nil {
		fake.newUnsupportedLegacyFlagRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.Requirement
		})
	}
	fake.newUnsupportedLegacyFlagRequirementReturnsOnCall[i] = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewUsageRequirement(arg1 requirements.Usable, arg2 string, arg3 func() bool) requirements.Requirement {
	fake.newUsageRequirementMutex.Lock()
	ret, specificReturn := fake.newUsageRequirementReturnsOnCall[len(fake.newUsageRequirementArgsForCall)]
	fake.newUsageRequirementArgsForCall = append(fake.newUsageRequirementArgsForCall, struct {
		arg1 requirements.Usable
		arg2 string
		arg3 func() bool
	}{arg1, arg2, arg3})
	fake.recordInvocation("NewUsageRequirement", []interface{}{arg1, arg2, arg3})
	fake.newUsageRequirementMutex.Unlock()
	if fake.NewUsageRequirementStub != nil {
		return fake.NewUsageRequirementStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newUsageRequirementReturns.result1
}

func (fake *FakeFactory) NewUsageRequirementCallCount() int {
	fake.newUsageRequirementMutex.RLock()
	defer fake.newUsageRequirementMutex.RUnlock()
	return len(fake.newUsageRequirementArgsForCall)
}

func (fake *FakeFactory) NewUsageRequirementArgsForCall(i int) (requirements.Usable, string, func() bool) {
	fake.newUsageRequirementMutex.RLock()
	defer fake.newUsageRequirementMutex.RUnlock()
	return fake.newUsageRequirementArgsForCall[i].arg1, fake.newUsageRequirementArgsForCall[i].arg2, fake.newUsageRequirementArgsForCall[i].arg3
}

func (fake *FakeFactory) NewUsageRequirementReturns(result1 requirements.Requirement) {
	fake.NewUsageRequirementStub = nil
	fake.newUsageRequirementReturns = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewUsageRequirementReturnsOnCall(i int, result1 requirements.Requirement) {
	fake.NewUsageRequirementStub = nil
	if fake.newUsageRequirementReturnsOnCall == nil {
		fake.newUsageRequirementReturnsOnCall = make(map[int]struct {
			result1 requirements.Requirement
		})
	}
	fake.newUsageRequirementReturnsOnCall[i] = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewNumberArguments(arg1 []string, arg2 ...string) requirements.Requirement {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.newNumberArgumentsMutex.Lock()
	ret, specificReturn := fake.newNumberArgumentsReturnsOnCall[len(fake.newNumberArgumentsArgsForCall)]
	fake.newNumberArgumentsArgsForCall = append(fake.newNumberArgumentsArgsForCall, struct {
		arg1 []string
		arg2 []string
	}{arg1Copy, arg2})
	fake.recordInvocation("NewNumberArguments", []interface{}{arg1Copy, arg2})
	fake.newNumberArgumentsMutex.Unlock()
	if fake.NewNumberArgumentsStub != nil {
		return fake.NewNumberArgumentsStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.newNumberArgumentsReturns.result1
}

func (fake *FakeFactory) NewNumberArgumentsCallCount() int {
	fake.newNumberArgumentsMutex.RLock()
	defer fake.newNumberArgumentsMutex.RUnlock()
	return len(fake.newNumberArgumentsArgsForCall)
}

func (fake *FakeFactory) NewNumberArgumentsArgsForCall(i int) ([]string, []string) {
	fake.newNumberArgumentsMutex.RLock()
	defer fake.newNumberArgumentsMutex.RUnlock()
	return fake.newNumberArgumentsArgsForCall[i].arg1, fake.newNumberArgumentsArgsForCall[i].arg2
}

func (fake *FakeFactory) NewNumberArgumentsReturns(result1 requirements.Requirement) {
	fake.NewNumberArgumentsStub = nil
	fake.newNumberArgumentsReturns = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) NewNumberArgumentsReturnsOnCall(i int, result1 requirements.Requirement) {
	fake.NewNumberArgumentsStub = nil
	if fake.newNumberArgumentsReturnsOnCall == nil {
		fake.newNumberArgumentsReturnsOnCall = make(map[int]struct {
			result1 requirements.Requirement
		})
	}
	fake.newNumberArgumentsReturnsOnCall[i] = struct {
		result1 requirements.Requirement
	}{result1}
}

func (fake *FakeFactory) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.newApplicationRequirementMutex.RLock()
	defer fake.newApplicationRequirementMutex.RUnlock()
	fake.newDEAApplicationRequirementMutex.RLock()
	defer fake.newDEAApplicationRequirementMutex.RUnlock()
	fake.newServiceInstanceRequirementMutex.RLock()
	defer fake.newServiceInstanceRequirementMutex.RUnlock()
	fake.newLoginRequirementMutex.RLock()
	defer fake.newLoginRequirementMutex.RUnlock()
	fake.newSpaceRequirementMutex.RLock()
	defer fake.newSpaceRequirementMutex.RUnlock()
	fake.newTargetedSpaceRequirementMutex.RLock()
	defer fake.newTargetedSpaceRequirementMutex.RUnlock()
	fake.newTargetedOrgRequirementMutex.RLock()
	defer fake.newTargetedOrgRequirementMutex.RUnlock()
	fake.newOrganizationRequirementMutex.RLock()
	defer fake.newOrganizationRequirementMutex.RUnlock()
	fake.newDomainRequirementMutex.RLock()
	defer fake.newDomainRequirementMutex.RUnlock()
	fake.newUserRequirementMutex.RLock()
	defer fake.newUserRequirementMutex.RUnlock()
	fake.newBuildpackRequirementMutex.RLock()
	defer fake.newBuildpackRequirementMutex.RUnlock()
	fake.newAPIEndpointRequirementMutex.RLock()
	defer fake.newAPIEndpointRequirementMutex.RUnlock()
	fake.newMinAPIVersionRequirementMutex.RLock()
	defer fake.newMinAPIVersionRequirementMutex.RUnlock()
	fake.newMaxAPIVersionRequirementMutex.RLock()
	defer fake.newMaxAPIVersionRequirementMutex.RUnlock()
	fake.newUnsupportedLegacyFlagRequirementMutex.RLock()
	defer fake.newUnsupportedLegacyFlagRequirementMutex.RUnlock()
	fake.newUsageRequirementMutex.RLock()
	defer fake.newUsageRequirementMutex.RUnlock()
	fake.newNumberArgumentsMutex.RLock()
	defer fake.newNumberArgumentsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFactory) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ requirements.Factory = new(FakeFactory)
